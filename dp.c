#include <stdio.h>

/*
 * 过程分成若干个互相联系的阶段, 在它的每一阶段都需要作
 * 出决策, 从而使整个过程达到最好的活动效果. 当然, 各个
 * 阶段决策的选取不是任意确定的, 它依赖于当前面临的状态,
 * 又影响以后的发展
 *
 * 1. 确定问题的决策对象
 * 2. 对决策过程划分阶段
 * 3. 对各阶段确定状态变量
 * 4. 根据状态变量确定费用函数和目标函数
 * 5. 建立各阶段状态变量的转移过程, 确定状态转移方程
 */

/*
 * 有 N 件物品和一个容量为 V 的背包. 第 i 件物品的重量是
 * c[i], 价值是 w[i]. 求解将哪些物品装入背包可使这些物品
 * 的重量总和不超过背包容量, 且价值总和最大.
 *
 * 用子问题定义状态: 即 f[i][v] 表示前 i 件物品恰放入一个
 * 容量为v的背包可以获得的最大价值. 则其状态转移方程便是:
 * f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}.
 *
 * 优化空间复杂度可以优化到O(V)
 * 主循环 i=1..N, 每次算出来二维数组 f[i][0..V] 所有值.
 * f[i][v] 是由 f[i-1][v] 和 f[i-1][v-c[i]] 两个子问题递推
 * 而来, 这要求在每次主循环中我们以 v=V..0 的顺序推f[v],
 * 这样保证推 f[v] 时 f[v-c[i]] 保存的是状态 f[i-1][v-c[i]] 的值:
 * for i = 1 to N
 *  for v = V to 0
 *   f[v] = max{f[v], f[v - c[i]] + w[i]};
 */


int main(void)
{
	int n, m, v, w, i, j;
	int f[100] = {0};

	scanf("%d%d", &n, &m);

	/* n 件物品, 背包容量为 m, 物件体积 w, 价值 v */
	for (i = 1; i <= n; i++) {
		scanf("%d%d", &v, &w);

		for (j = m; j >= w; j--)
			if (f[j] < f[j - w] + v)
				f[j] = f[j - w] + v;
	}
	printf("%d\n", f[m]);
	return 0;
}


/*
 * 给你一个数字三角形, 形式如下:
 *       7
 *     3   8
 *   8   1   0
 * 7   12 10   10
 * 找出从第一层到最后一层的一条路, 使得所经过的权值之和
 * 最小或者最大.
 * f(i, j) 记录以 r[i][j] 为顶点向下走到底边可以得到的最大和
 * f(i, j) = a[i, j] + max{f(i - 1, j), f(i, j - 1)}
 *
 *       7
 *     3   8                7
 *   8   1   0    --->    3   8   --->    7
 * 7   12 10   10       20 13   10      23 21
 *
 */

/*
 * 动态规划法解决最大连续子序列和
 * 解决方法：
 * 设 f[j] 表示第j处, 以 a[j] 结尾的子序列的最大和
 * 则 f[j] = max(a[j] + f[j-1], a[j])
 * 我们求得最大的 f[j] 即可。
 */


/*
 * 有 F 束花, V(V > F) 个花瓶, 被按顺序摆成一行, 花瓶的位
 * 置是固定的, 并从左到右, 从 1 到 V 顺序编号, 每个花瓶中
 * 只能放一束花. 各个花瓶中放入同的花束时会产生不同的美
 * 学效果, 并以美学值(一个整数)来表示, 空置花瓶的美学值为
 * 0. 求最大美值.
 * .---------------------------.
 * |       | 1 | 2 | 3 | 4 | 5 |
 * .-------+---+---+---+---+---.
 * |杜鹃花 | 7 |23 |-5 |-24|16 |
 * .-------+---+---+---+---+---.
 * |秋海棠 | 5 |21 |-4 |10 |23 |
 * .-------+---+---+---+---+---.
 * |康乃馨 |-21| 5 |-4 |-20|20 |
 * ^---------------------------^
 * 经建模分析, 此问题同数字三角塔.
 */

/*
 * 最大子段和
 * a: 2 3 -7 6 4 -5
 * b: 2 5 -2 6 10 5
 * b[i] = max(b[i-1], a[i]);
 */





















